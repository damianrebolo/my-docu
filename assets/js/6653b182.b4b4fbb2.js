"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7631],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),p=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=p(e.components);return n.createElement(c.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),y=p(a),d=r,u=y["".concat(c,".").concat(d)]||y[d]||l[d]||o;return a?n.createElement(u,s(s({ref:t},h),{},{components:a})):n.createElement(u,s({ref:t},h))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=y;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}y.displayName="MDXCreateElement"},8246:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={id:"w3-cryptography",title:"Cryptography",sidebar_label:"Cryptography",slug:"/w3-cryptography"},s=void 0,i={unversionedId:"web3/w3-cryptography",id:"web3/w3-cryptography",title:"Cryptography",description:"Cryptography Historically",source:"@site/docs/web3/w3-cryptography.md",sourceDirName:"web3",slug:"/w3-cryptography",permalink:"/my-docu/docs/w3-cryptography",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/web3/w3-cryptography.md",tags:[],version:"current",frontMatter:{id:"w3-cryptography",title:"Cryptography",sidebar_label:"Cryptography",slug:"/w3-cryptography"},sidebar:"mySidebar",previous:{title:"Cryptographic Hashes",permalink:"/my-docu/docs/w3-cryptographic-hashes"},next:{title:"Proof of Work & Mining",permalink:"/my-docu/docs/w3-pow-mining"}},c={},p=[{value:"Cryptography Historically",id:"cryptography-historically",level:2},{value:"How could two parties communicate securely without having met beforehand to exchange keys?",id:"how-could-two-parties-communicate-securely-without-having-met-beforehand-to-exchange-keys",level:3},{value:"RSA and ECDSA",id:"rsa-and-ecdsa",level:2},{value:"Hashing Messages",id:"hashing-messages",level:3},{value:"Signing the Hash",id:"signing-the-hash",level:3},{value:"Recover the Public Key",id:"recover-the-public-key",level:3},{value:"Public Key to Address",id:"public-key-to-address",level:3}],h={toc:p};function l(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"cryptography-historically"},"Cryptography Historically"),(0,r.kt)("p",null,"Historically, up until the 1970s, cryptography was the study of encrypting messages so that they could not be decrypted even if intercepted. Cryptography was used for passing important secrets, especially within the military. The sender would take their message and pass it through a function to create an encrypted output."),(0,r.kt)("p",null,"As cryptography advanced over the years, more complex functions were introduced to hide messages better. One important leap forward was the idea of a ",(0,r.kt)("strong",{parentName:"p"},"secret key"),"."),(0,r.kt)("p",null,"If two parties can meet prior to their exchange of messages they both can come to an agreement upon a particular key. This key plus a function (like the alphabet shift mentioned above) could be used together to create a more secure encryption."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Having keys on both sides of the message is considered ",(0,r.kt)("strong",{parentName:"p"},"symmetric-key cryptography"),".")),(0,r.kt)("h3",{id:"how-could-two-parties-communicate-securely-without-having-met-beforehand-to-exchange-keys"},"How could two parties communicate securely without having met beforehand to exchange keys?"),(0,r.kt)("p",null,"In 1976 Whitfield Diffie proposed an idea. What if there was a ",(0,r.kt)("strong",{parentName:"p"},"public key"),"?"),(0,r.kt)("p",null,"Let's say there is a ",(0,r.kt)("strong",{parentName:"p"},"private key")," that can decrypt a message from a ",(0,r.kt)("strong",{parentName:"p"},"public key")," and ",(0,r.kt)("strong",{parentName:"p"},"vice-versa"),". Each key is the only key that can decrypt a message encrypted by the other key."),(0,r.kt)("p",null,"Now imagine ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob")," has declared a ",(0,r.kt)("strong",{parentName:"p"},"public key")," far and wide as the key that identifies him. ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob")," will keep a ",(0,r.kt)("strong",{parentName:"p"},"private key")," that corresponds to his ",(0,r.kt)("strong",{parentName:"p"},"public key"),". When he uses his private key to encrypt a message, he can share it publicly to be decrypted using his ",(0,r.kt)("strong",{parentName:"p"},"public key"),". Upon decrypting this message, we can say beyond the shadow of a doubt that only ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob")," could have written this message. The only key that could have encrypted the message is the corresponding ",(0,r.kt)("strong",{parentName:"p"},"private key")," which only ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob")," has access to. In practice, this would create an unforgeable digital signature for ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob"),"."),(0,r.kt)("p",null,"On the flip side, what if a message was encrypted using ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob's")," ",(0,r.kt)("strong",{parentName:"p"},"public key"),"? Of course, anyone can do this since ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob's")," ",(0,r.kt)("strong",{parentName:"p"},"public key")," is available to everyone. The benefit comes in that only ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob")," can decrypt the message. In this way, a friend of ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob's")," can write a message that can only be read by ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob"),". They could send it through any network, regardless of its security so long as it reaches ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob"),". They could rest assured that nobody would be able to decrypt the message except for ",(0,r.kt)("inlineCode",{parentName:"p"},"Bob"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"As opposed to the encryption techniques mentioned in the above section, public key cryptography is considered ",(0,r.kt)("strong",{parentName:"p"},"asymmetric encryption")," in that only one party has access to the private key.")),(0,r.kt)("h2",{id:"rsa-and-ecdsa"},"RSA and ECDSA"),(0,r.kt)("p",null,"Today, both ",(0,r.kt)("strong",{parentName:"p"},"RSA")," and ",(0,r.kt)("strong",{parentName:"p"},"ECDSA")," are two popularly used algorithms for ",(0,r.kt)("inlineCode",{parentName:"p"},"public key cryptography"),"."),(0,r.kt)("h3",{id:"hashing-messages"},"Hashing Messages"),(0,r.kt)("p",null,'So if you wanted to sign a message with one your keypairs saying that you "Vote Yes on Proposal 327", the first step would be to hash this message:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// turn this into an array of bytes, the expected format for the hash algorithm\nconst bytes = utf8ToBytes("Vote Yes on Proposal 327");\n// hash the message using keccak256\nconst hash = keccak256(bytes);\n\nconsole.log(toHex(hash)); // 928c3f25193b338b89d5646bebbfa2436c5daa1d189f9c565079dcae379a43be\n')),(0,r.kt)("h3",{id:"signing-the-hash"},"Signing the Hash"),(0,r.kt)("p",null,"When signing a message with ",(0,r.kt)("inlineCode",{parentName:"p"},"secp256k1")," we can return the signature along with the ",(0,r.kt)("inlineCode",{parentName:"p"},"recovery bit"),", allowing us to recover the ",(0,r.kt)("strong",{parentName:"p"},"public key")," from the signature."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const secp = require("ethereum-cryptography/secp256k1");\nconst hashMessage = require("./hashMessage");\n\nconst PRIVATE_KEY =\n  "6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e";\n\nasync function signMessage(msg) {\n  const hash = hashMessage(msg);\n  const signatureM = await secp.sign(hash, PRIVATE_KEY, { recovered: true });\n  return signatureM;\n}\n\nmodule.exports = signMessage;\n')),(0,r.kt)("h3",{id:"recover-the-public-key"},"Recover the Public Key"),(0,r.kt)("p",null,"When the signature is passed with all of its components (recovery bit included), the public key can be recovered. This means that blockchain nodes will be able to understand who signed the transaction that was sent to them."),(0,r.kt)("p",null,"A transaction could indicate the user would like to send 1 ether to another address and provide a certain transaction fee. Since the signature signs the hash containing this intention, it is enough to authenticate this action entirely."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const secp = require("ethereum-cryptography/secp256k1");\nconst hashMessage = require("./hashMessage");\n\nasync function recoverKey(message, signature, recoveryBit) {\n  const hashMsg = hashMessage(message);\n  const publicKey = secp.recoverPublicKey(hashMsg, signature, recoveryBit);\n  return publicKey;\n}\n\nmodule.exports = recoverKey;\n')),(0,r.kt)("h3",{id:"public-key-to-address"},"Public Key to Address"),(0,r.kt)("p",null,"Bitcoin and Ethereum both have a transformation process to take a public key and turn it into an address. Ethereum's address transformation is quite simple, its address is the last 20 bytes of the hash of the public key."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const { keccak256 } = require("ethereum-cryptography/keccak");\n\nfunction getAddress(publicKey) {\n  return keccak256(publicKey.slice(1)).slice(-20);\n}\n\nmodule.exports = getAddress;\n')),(0,r.kt)("admonition",{type:"important"},(0,r.kt)("p",{parentName:"admonition"},"The important thing to recognize here is that the address is differentiated from the public key, but you can always derive the address if you have the public key.")))}l.isMDXComponent=!0}}]);
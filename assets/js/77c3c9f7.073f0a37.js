"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4244],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),h=c(n),u=r,k=h["".concat(l,".").concat(u)]||h[u]||p[u]||o;return n?a.createElement(k,s(s({ref:t},d),{},{components:n})):a.createElement(k,s({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3789:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={id:"tok-tokens",title:"Tokens",sidebar_label:"Tokens",slug:"/tokens"},s=void 0,i={unversionedId:"eth/tok-tokens",id:"eth/tok-tokens",title:"Tokens",description:"Tokens on Ethereum",source:"@site/docs/eth/tokens.md",sourceDirName:"eth",slug:"/tokens",permalink:"/my-docu/docs/tokens",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/eth/tokens.md",tags:[],version:"current",frontMatter:{id:"tok-tokens",title:"Tokens",sidebar_label:"Tokens",slug:"/tokens"},sidebar:"mySidebar",previous:{title:"Smart Contract - Advanced",permalink:"/my-docu/docs/sol-advanced"}},l={},c=[{value:"Tokens on Ethereum",id:"tokens-on-ethereum",level:2},{value:"Why does it matter?",id:"why-does-it-matter",level:3},{value:"Other token standards",id:"other-token-standards",level:3},{value:"ERC721: Transfer Logic",id:"erc721-transfer-logic",level:2}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"tokens-on-ethereum"},"Tokens on Ethereum"),(0,r.kt)("p",null,"A token on Ethereum is basically just a smart contract that follows some common rules \u2014 namely it implements a standard set of functions that all other token contracts share, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom(address _from, address _to, uint256 _amount)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"balanceOf(address _owner)"),"."),(0,r.kt)("p",null,"Internally the smart contract usually has a mapping, ",(0,r.kt)("inlineCode",{parentName:"p"},"mapping(address => uint256) balances"),", that keeps track of how much balance each address has."),(0,r.kt)("p",null,"So basically a token is just a contract that keeps track of who owns how much of that token, and some functions so those users can transfer their tokens to other addresses."),(0,r.kt)("h3",{id:"why-does-it-matter"},"Why does it matter?"),(0,r.kt)("p",null,"Since all ERC20 tokens share the same set of functions with the same names, they can all be interacted with in the same ways."),(0,r.kt)("p",null,"This means if you build an application that is capable of interacting with one ERC20 token, it's also capable of interacting with any ERC20 token. That way more tokens can easily be added to your app in the future without needing to be custom coded. You could simply plug in the new token contract address, and boom, your app has another token it can use."),(0,r.kt)("p",null,"One example of this would be an exchange. When an exchange adds a new ERC20 token, really it just needs to add another smart contract it talks to. Users can tell that contract to send tokens to the exchange's wallet address, and the exchange can tell the contract to send the tokens back out to users when they request a withdraw."),(0,r.kt)("p",null,"The exchange only needs to implement this transfer logic once, then when it wants to add a new ERC20 token, it's simply a matter of adding the new contract address to its database."),(0,r.kt)("h3",{id:"other-token-standards"},"Other token standards"),(0,r.kt)("p",null,"ERC20 tokens are really cool for tokens that act like currencies."),(0,r.kt)("p",null,"ERC721 tokens are not interchangeable since each one is assumed to be unique, and are not divisible. You can only trade them in whole units, and each one has a unique ID."),(0,r.kt)("h2",{id:"erc721-transfer-logic"},"ERC721: Transfer Logic"),(0,r.kt)("p",null,"Note that the ERC721 spec has 2 different ways to transfer tokens:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"function transferFrom(address _from, address _to, uint256 _tokenId) external payable;")),(0,r.kt)("p",null,"The token's owner calls ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom")," with his ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," as the ",(0,r.kt)("inlineCode",{parentName:"p"},"_from")," parameter, the ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," he wants to transfer to as the ",(0,r.kt)("inlineCode",{parentName:"p"},"_to")," parameter, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"_tokenId")," of the token he wants to transfer."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"function approve(address _approved, uint256 _tokenId) external payable;"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"function transferFrom(address _from, address _to, uint256 _tokenId) external payable;")),(0,r.kt)("p",null,"The token's owner first calls ",(0,r.kt)("inlineCode",{parentName:"p"},"approve")," with the address he wants to transfer to, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"_tokenID")," . The contract then stores who is approved to take a token, usually in a ",(0,r.kt)("inlineCode",{parentName:"p"},"mapping (uint256 => address)"),". Then, when the owner or the approved address calls ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom"),", the contract checks if that ",(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender")," is the owner or is approved by the owner to take the token, and if so it transfers the token to him."),(0,r.kt)("p",null,"Notice that both methods contain the same transfer logic. In one case the sender of the token calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom")," function; in the other the owner or the approved receiver of the token calls it."))}p.isMDXComponent=!0}}]);